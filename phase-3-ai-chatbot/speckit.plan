# Phase II-III Todo Application - Implementation Plan

**Document Type:** Implementation Plan (HOW to build)
**Phase:** II-III - Full-Stack Web Application with AI Chatbot
**Version:** 2.0.0
**Date:** 2026-01-12
**Status:** Ready for Implementation

---

## 1. SYSTEM ARCHITECTURE

### High-Level Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Browser                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚           Next.js Frontend (Vercel)                 â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  Server Components (SSR)                    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - app/page.tsx (task list)                 â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - app/login/page.tsx                       â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - app/signup/page.tsx                      â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  Client Components (React)                  â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - TaskForm.tsx (forms)                     â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - TaskItem.tsx (interactive)               â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  Better Auth (JWT)                          â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - /api/auth/[...route]/route.ts            â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - httpOnly cookies                         â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  API Client (/lib/api.ts)                   â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - Auto JWT injection                       â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - Error handling                           â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ HTTPS + JWT in Cookie
                    â”‚ (Authorization: Bearer <token>)
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           FastAPI Backend (Railway/Render)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  JWT Verification Middleware                        â”‚   â”‚
â”‚  â”‚  - Extract token from Authorization header         â”‚   â”‚
â”‚  â”‚  - Verify signature with BETTER_AUTH_SECRET        â”‚   â”‚
â”‚  â”‚  - Extract user_id from 'sub' claim                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                   â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Task CRUD Endpoints (routes/tasks.py)             â”‚   â”‚
â”‚  â”‚  - GET    /api/{user_id}/tasks                     â”‚   â”‚
â”‚  â”‚  - POST   /api/{user_id}/tasks                     â”‚   â”‚
â”‚  â”‚  - GET    /api/{user_id}/tasks/{id}                â”‚   â”‚
â”‚  â”‚  - PUT    /api/{user_id}/tasks/{id}                â”‚   â”‚
â”‚  â”‚  - DELETE /api/{user_id}/tasks/{id}                â”‚   â”‚
â”‚  â”‚  - PATCH  /api/{user_id}/tasks/{id}/complete       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                   â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  SQLModel ORM + Pydantic Validation                â”‚   â”‚
â”‚  â”‚  - models.py (Task model)                          â”‚   â”‚
â”‚  â”‚  - schemas.py (request/response validation)        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ asyncpg
                    â”‚ (PostgreSQL Wire Protocol)
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Neon PostgreSQL (Cloud)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Tables:                                            â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  users                                       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - id (VARCHAR PK)                           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - email (VARCHAR UNIQUE)                    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - name (VARCHAR)                            â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - hashed_password (VARCHAR)                 â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - created_at (TIMESTAMP)                    â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  tasks                                       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - id (INTEGER PK AUTOINCREMENT)             â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - user_id (VARCHAR FK â†’ users.id)           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - title (VARCHAR 200)                       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - description (VARCHAR 1000)                â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - completed (BOOLEAN)                       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - created_at (TIMESTAMP)                    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - updated_at (TIMESTAMP)                    â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  Indexes:                                           â”‚   â”‚
â”‚  â”‚  - idx_users_email (UNIQUE)                         â”‚   â”‚
â”‚  â”‚  - idx_tasks_user_id                                â”‚   â”‚
â”‚  â”‚  - idx_tasks_completed                              â”‚   â”‚
â”‚  â”‚  - idx_tasks_created_at                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Phase III: AI Chatbot Architecture Extension

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Browser                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚           Next.js Frontend (Vercel)                 â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  Chat Page (NEW - Phase III)                â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - app/chat/page.tsx                        â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - OpenAI ChatKit components                â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - Message history display                  â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - Chat input with send button              â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  Chat API Client (/lib/chat-api.ts)         â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - POST /api/chat/message                   â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - JWT in httpOnly cookie                   â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  - Conversation state management            â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚                                                      â”‚   â”‚
â”‚  â”‚  [Phase II Components remain unchanged]             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ HTTPS + JWT in Cookie
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           FastAPI Backend (Railway/Render)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  JWT Verification Middleware (Phase II - reused)    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                   â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Chat Endpoint (NEW - Phase III)                   â”‚   â”‚
â”‚  â”‚  POST /api/chat/message                            â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚ 1. Verify JWT & extract user_id            â”‚    â”‚   â”‚
â”‚  â”‚  â”‚ 2. Get or create conversation              â”‚    â”‚   â”‚
â”‚  â”‚  â”‚ 3. Fetch conversation history (20 msgs)    â”‚    â”‚   â”‚
â”‚  â”‚  â”‚ 4. Store user message in database          â”‚    â”‚   â”‚
â”‚  â”‚  â”‚ 5. Build message array for AI              â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                   â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  OpenAI Agent Processing (NEW - Phase III)         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚  OpenAI Agents SDK                         â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - AsyncOpenAI client (GPT-4o/mini)       â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - System prompt injection                 â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Tool calling orchestration              â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Multi-turn conversations (max 5)        â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                 â–¼                                   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚  MCP Server (5 Tools)                      â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - add_task(user_id, title, ...)          â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - list_tasks(user_id, filters)           â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - update_task(user_id, task_id, ...)     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - complete_task(user_id, task_id)        â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - delete_task(user_id, task_id)          â”‚    â”‚   â”‚
â”‚  â”‚  â”‚                                             â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  Stateless: ALL filter by user_id          â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                   â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Conversation State Management (NEW - Phase III)   â”‚   â”‚
â”‚  â”‚  - ConversationService (stateless)                 â”‚   â”‚
â”‚  â”‚  - Store assistant response in database            â”‚   â”‚
â”‚  â”‚  - Update conversation updated_at timestamp        â”‚   â”‚
â”‚  â”‚  - Return response to client                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                   â–¼                                         â”‚
â”‚  â”‚  [Phase II Task CRUD Endpoints remain unchanged]   â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  SQLModel ORM (Extended for Phase III)             â”‚   â”‚
â”‚  â”‚  - models.py: Task, User (Phase II)                â”‚   â”‚
â”‚  â”‚  - models.py: Conversation, Message (Phase III)    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚ asyncpg (PostgreSQL Wire Protocol)
                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Neon PostgreSQL (Cloud)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Phase II Tables (unchanged):                       â”‚   â”‚
â”‚  â”‚  - users                                            â”‚   â”‚
â”‚  â”‚  - tasks                                            â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  Phase III Tables (NEW):                           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  conversations                               â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - id (INTEGER PK AUTOINCREMENT)             â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - user_id (VARCHAR FK â†’ users.id)           â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - title (VARCHAR 200)                       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - created_at (TIMESTAMP)                    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - updated_at (TIMESTAMP)                    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - is_active (BOOLEAN)                       â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  messages                                    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - id (INTEGER PK AUTOINCREMENT)             â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - conversation_id (INTEGER FK â†’ conv.id)    â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - role (VARCHAR 20)  # user|assistant       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - content (TEXT)                            â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - created_at (TIMESTAMP)                    â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                                                     â”‚   â”‚
â”‚  â”‚  Phase III Indexes (NEW):                          â”‚   â”‚
â”‚  â”‚  - idx_conversations_user_updated                   â”‚   â”‚
â”‚  â”‚  - idx_conversations_user_active                    â”‚   â”‚
â”‚  â”‚  - idx_messages_conversation_created                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   OpenAI API (Cloud)   â”‚
                    â”‚  - GPT-4o / GPT-4o-miniâ”‚
                    â”‚  - Tool calling supportâ”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â–²
                              â”‚ HTTPS
                              â”‚ (OpenAI API Key)
                              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  FastAPI Backend  â”‚
                    â”‚  OpenAI Agent SDK â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow

**1. Authentication Flow:**
```
User â†’ Login Form â†’ Better Auth â†’ JWT Generated â†’ httpOnly Cookie â†’ Browser
```

**2. Create Task Flow:**
```
User â†’ TaskForm â†’ API Client â†’ POST /api/{user_id}/tasks
                                â†“
                        JWT Middleware (verify)
                                â†“
                        Validate user_id match
                                â†“
                        SQLModel Insert
                                â†“
                        PostgreSQL (Neon)
                                â†“
                        Return Task Object
                                â†“
                        Update UI (React)
```

**3. List Tasks Flow:**
```
User â†’ Page Load â†’ GET /api/{user_id}/tasks?status=all
                        â†“
                JWT Middleware (verify)
                        â†“
                Filter by user_id
                        â†“
                SQLModel Query
                        â†“
                PostgreSQL (Neon)
                        â†“
                Return Task[]
                        â†“
                Render TaskList
```

---

**Phase III Data Flows:**

**4. AI Chat Message Flow (Stateless):**
```
User types message â†’ Chat Input (ChatKit)
                        â†“
                Send message to backend
                        â†“
        POST /api/chat/message
        Body: {conversation_id?, message: "Add task to buy groceries"}
        Cookie: JWT token
                        â†“
                JWT Middleware (verify user_id)
                        â†“
        ConversationService.get_or_create_conversation(user_id, conversation_id?)
                        â†“
        Fetch conversation history from DB (last 20 messages)
                        â†“
        Store user message in messages table
                        â†“
        Build message array: [system_prompt, history..., new_message]
                        â†“
        OpenAI Agent.run(messages, user_id)
            â†“
            OpenAI API call (GPT-4o)
            â†“
            AI extracts intent: "create task"
            â†“
            AI calls MCP tool: add_task(user_id=42, title="Buy groceries")
                â†“
                MCP tool â†’ Database INSERT (tasks table, user_id=42)
                â†“
                Return: {success: true, data: {id: 123, title: "Buy groceries"}}
            â†“
            AI formats response: "âœ… Created task: Buy groceries. Anything else?"
            â†“
            Return AI response to backend
                        â†“
        Store assistant message in messages table
                        â†“
        Update conversation.updated_at timestamp
                        â†“
        Return response to client
        Response: {conversation_id: 1, response: "âœ… Created task..."}
                        â†“
        Update Chat UI with AI response
                        â†“
        Display message in chat history
```

**5. AI Chat with Multi-turn Tool Calls:**
```
User: "Show me my tasks and mark the first one done"
                        â†“
        POST /api/chat/message
                        â†“
        [Same stateless cycle: verify JWT, get conversation, fetch history]
                        â†“
        OpenAI Agent processes request
            â†“
            Iteration 1: Call list_tasks(user_id=42)
                â†“
                MCP tool â†’ SELECT * FROM tasks WHERE user_id=42
                â†“
                Return: {tasks: [{id: 1, title: "Buy groceries"}, ...]}
            â†“
            AI receives task list, identifies first task (id=1)
            â†“
            Iteration 2: Call complete_task(user_id=42, task_id=1)
                â†“
                MCP tool â†’ UPDATE tasks SET completed=true WHERE id=1 AND user_id=42
                â†“
                Return: {success: true, data: {id: 1, completed: true}}
            â†“
            AI formats response with both results
            â†“
            Return: "You have 3 tasks: [...]. I marked 'Buy groceries' as complete! ğŸ‰"
                        â†“
        Store assistant response in database
                        â†“
        Return to client
                        â†“
        Update Chat UI
```

**6. Conversation Persistence (Server Restart Scenario):**
```
User sends message â†’ Backend processes â†’ Server crashes
                        â†“
        User message stored in DB âœ…
        AI response stored in DB âœ…
                        â†“
Server restarts (no state loss)
                        â†“
User refreshes page â†’ Load /chat
                        â†“
        GET /api/conversations/{id}/messages
                        â†“
        Fetch messages from DB (stateless)
                        â†“
        Return: [{role: "user", content: "..."},
                 {role: "assistant", content: "..."}]
                        â†“
        Render full conversation history
                        â†“
User continues conversation seamlessly âœ…
```

**Key Architectural Decisions:**
- **Stateless**: No server memory, all state in PostgreSQL
- **Security**: user_id always from JWT, never from client input
- **Scalability**: Multiple backend instances, any handles any request
- **Reliability**: Conversations survive server restarts
- **Performance**: Index on (user_id, updated_at) for fast conversation fetch

---

## 2. COMPONENT BREAKDOWN

### Frontend Components (Next.js)

#### App Router Structure
```
frontend/src/app/
â”œâ”€â”€ layout.tsx                 # Root layout with providers
â”‚   - AuthProvider (Better Auth context)
â”‚   - Tailwind CSS imports
â”‚   - Metadata configuration
â”‚
â”œâ”€â”€ page.tsx                   # Home page (task list)
â”‚   - Server Component (default)
â”‚   - Fetches tasks on server
â”‚   - Renders TaskList component
â”‚
â”œâ”€â”€ login/
â”‚   â””â”€â”€ page.tsx               # Login page
â”‚       - LoginForm component
â”‚       - Redirect to /tasks on success
â”‚
â”œâ”€â”€ signup/
â”‚   â””â”€â”€ page.tsx               # Signup page
â”‚       - SignupForm component
â”‚       - Redirect to /tasks on success
â”‚
â””â”€â”€ api/
    â””â”€â”€ auth/
        â””â”€â”€ [...route]/
            â””â”€â”€ route.ts       # Better Auth API routes
                - Handles signup, login, logout
                - JWT token generation
                - Cookie management
```

#### Component Library
```
frontend/src/components/
â”œâ”€â”€ Header.tsx                 # App header
â”‚   Props: { user?: User }
â”‚   Features:
â”‚   - App title/logo
â”‚   - User menu (name, logout)
â”‚   - Responsive mobile menu
â”‚   Type: Client Component ('use client')
â”‚
â”œâ”€â”€ TaskList.tsx               # List of tasks
â”‚   Props: { initialTasks: Task[], userId: string }
â”‚   Features:
â”‚   - Filter tabs (All, Pending, Completed)
â”‚   - Empty state message
â”‚   - Task count display
â”‚   - Renders TaskItem for each task
â”‚   Type: Client Component (state management)
â”‚
â”œâ”€â”€ TaskItem.tsx               # Individual task card
â”‚   Props: { task: Task, onUpdate, onDelete }
â”‚   Features:
â”‚   - Checkbox for completion toggle
â”‚   - Title and description display
â”‚   - Edit/Delete buttons
â”‚   - Inline editing mode
â”‚   - Optimistic updates
â”‚   Type: Client Component (interactive)
â”‚
â”œâ”€â”€ TaskForm.tsx               # Add/Edit task form
â”‚   Props: { userId: string, task?: Task, onSubmit, onCancel }
â”‚   Features:
â”‚   - Title input (required, max 200)
â”‚   - Description textarea (optional, max 1000)
â”‚   - Character count display
â”‚   - Validation feedback
â”‚   - Submit/Cancel buttons
â”‚   Type: Client Component (form state)
â”‚
â”œâ”€â”€ LoginForm.tsx              # Login form
â”‚   Props: { onSuccess?: () => void }
â”‚   Features:
â”‚   - Email input (validation)
â”‚   - Password input (masked)
â”‚   - Submit button (loading state)
â”‚   - Error message display
â”‚   - Link to signup page
â”‚   Type: Client Component (form handling)
â”‚
â””â”€â”€ SignupForm.tsx             # Signup form
    Props: { onSuccess?: () => void }
    Features:
    - Name input (2-100 chars)
    - Email input (validation)
    - Password input (min 8 chars)
    - Submit button (loading state)
    - Error message display
    - Link to login page
    Type: Client Component (form handling)
```

#### Library Code
```
frontend/src/lib/
â”œâ”€â”€ api.ts                     # API client
â”‚   Functions:
â”‚   - getTasks(userId, status?)
â”‚   - getTask(userId, taskId)
â”‚   - createTask(userId, data)
â”‚   - updateTask(userId, taskId, data)
â”‚   - deleteTask(userId, taskId)
â”‚   - toggleComplete(userId, taskId)
â”‚   Features:
â”‚   - Automatic JWT injection from cookie
â”‚   - Error handling (401 â†’ logout, 403 â†’ error, etc.)
â”‚   - TypeScript types for all requests/responses
â”‚
â”œâ”€â”€ auth.ts                    # Better Auth configuration
â”‚   Exports:
â”‚   - auth client instance
â”‚   - JWT plugin configuration
â”‚   - Session helpers (getUser, logout)
â”‚
â””â”€â”€ types.ts                   # TypeScript types
    Types:
    - User { id, email, name, created_at }
    - Task { id, user_id, title, description, completed, created_at, updated_at }
    - TaskCreate { title, description? }
    - TaskUpdate { title?, description?, completed? }
    - ApiError { detail: string }
```

---

### Backend Components (FastAPI)

#### Project Structure
```
backend/
â”œâ”€â”€ main.py                    # FastAPI app entry point
â”‚   Features:
â”‚   - App initialization
â”‚   - CORS middleware
â”‚   - Lifespan context manager (DB connection)
â”‚   - Router registration
â”‚   - Health check endpoint
â”‚
â”œâ”€â”€ models.py                  # SQLModel database models
â”‚   Models:
â”‚   - User (Better Auth managed)
â”‚   - Task (application model)
â”‚
â”œâ”€â”€ schemas.py                 # Pydantic request/response schemas
â”‚   Schemas:
â”‚   - TaskCreate (request)
â”‚   - TaskUpdate (request)
â”‚   - TaskResponse (response)
â”‚   - ErrorResponse (error)
â”‚
â”œâ”€â”€ db.py                      # Database connection
â”‚   Functions:
â”‚   - create_async_engine()
â”‚   - get_db() dependency
â”‚   - AsyncSession management
â”‚
â”œâ”€â”€ config.py                  # Environment configuration
â”‚   Settings:
â”‚   - DATABASE_URL
â”‚   - BETTER_AUTH_SECRET
â”‚   - CORS_ORIGINS
â”‚   - DEBUG mode
â”‚
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ auth.py                # JWT verification middleware
â”‚       Functions:
â”‚       - verify_jwt() dependency
â”‚       - Extract user_id from token
â”‚
â””â”€â”€ routes/
    â””â”€â”€ tasks.py               # Task CRUD endpoints
        Endpoints:
        - list_tasks()
        - create_task()
        - get_task()
        - update_task()
        - delete_task()
        - toggle_complete()
```

---

## 3. DATABASE MODELS

### User Model (SQLModel)

**File:** `backend/models.py`

```python
from datetime import datetime
from typing import Optional
from sqlmodel import Field, SQLModel, Relationship


class User(SQLModel, table=True):
    """User model for authentication (Better Auth managed)."""

    __tablename__ = "users"

    id: str = Field(primary_key=True)  # UUID string
    email: str = Field(unique=True, index=True, max_length=255)
    name: str = Field(max_length=100)
    hashed_password: str = Field(max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationship
    tasks: list["Task"] = Relationship(back_populates="user", cascade_delete=True)
```

**Notes:**
- Better Auth manages user creation and password hashing
- Application only reads from this table
- Cascade delete ensures tasks are removed when user is deleted

---

### Task Model (SQLModel)

**File:** `backend/models.py`

```python
class Task(SQLModel, table=True):
    """Task model for todo items."""

    __tablename__ = "tasks"

    # Primary key (auto-increment)
    id: Optional[int] = Field(default=None, primary_key=True)

    # Foreign key to users
    user_id: str = Field(foreign_key="users.id", index=True)

    # Task data
    title: str = Field(max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)
    completed: bool = Field(default=False, index=True)

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationship
    user: User = Relationship(back_populates="tasks")
```

**Indexes:**
- `user_id` - For filtering tasks by user (performance)
- `completed` - For filtering by completion status
- `created_at` - For sorting by date

**Constraints:**
- `user_id` must reference valid user (foreign key)
- `title` cannot be NULL
- `title` max 200 characters
- `description` max 1000 characters

---

### Pydantic Schemas

**File:** `backend/schemas.py`

```python
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field, validator


class TaskCreate(BaseModel):
    """Schema for creating a new task."""

    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)

    @validator('title')
    def title_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('Title cannot be empty')
        return v.strip()


class TaskUpdate(BaseModel):
    """Schema for updating an existing task."""

    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)
    completed: Optional[bool] = None

    @validator('title')
    def title_must_not_be_empty(cls, v):
        if v is not None and not v.strip():
            raise ValueError('Title cannot be empty')
        return v.strip() if v else None


class TaskResponse(BaseModel):
    """Schema for task response."""

    id: int
    user_id: str
    title: str
    description: Optional[str]
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True
```

---

### Phase III: Conversation Model (SQLModel)

**File:** `backend/models.py`

```python
class Conversation(SQLModel, table=True):
    """Conversation model for AI chat sessions (Phase III)."""

    __tablename__ = "conversations"

    # Primary key (auto-increment)
    id: Optional[int] = Field(default=None, primary_key=True)

    # Foreign key to users
    user_id: str = Field(foreign_key="users.id", index=True)

    # Conversation metadata
    title: Optional[str] = Field(default=None, max_length=200)
    is_active: bool = Field(default=True, index=True)

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow, index=True)

    # Relationships
    user: User = Relationship(back_populates="conversations")
    messages: list["Message"] = Relationship(back_populates="conversation", cascade_delete=True)
```

**Indexes:**
- `user_id` + `updated_at` - For fetching user's recent conversations (performance)
- `user_id` + `is_active` - For filtering active conversations
- `updated_at` - For sorting conversations by recent activity

**Constraints:**
- `user_id` must reference valid user (foreign key)
- `title` max 200 characters
- `is_active` defaults to true (soft delete support)

**Usage Pattern (Stateless):**
```python
# Get or create conversation (stateless - always fetch from DB)
async def get_or_create_conversation(
    db: AsyncSession,
    user_id: str,
    conversation_id: Optional[int] = None
) -> Conversation:
    """Get existing conversation or create new one."""
    if conversation_id:
        # Fetch existing conversation
        result = await db.execute(
            select(Conversation).where(
                Conversation.id == conversation_id,
                Conversation.user_id == user_id  # SECURITY: user isolation
            )
        )
        conversation = result.scalar_one_or_none()
        if not conversation:
            raise HTTPException(404, "Conversation not found")
        return conversation
    else:
        # Create new conversation
        conversation = Conversation(user_id=user_id, title="New Chat")
        db.add(conversation)
        await db.commit()
        await db.refresh(conversation)
        return conversation
```

---

### Phase III: Message Model (SQLModel)

**File:** `backend/models.py`

```python
class Message(SQLModel, table=True):
    """Message model for conversation messages (Phase III)."""

    __tablename__ = "messages"

    # Primary key (auto-increment)
    id: Optional[int] = Field(default=None, primary_key=True)

    # Foreign key to conversations
    conversation_id: int = Field(foreign_key="conversations.id", index=True)

    # Message data
    role: str = Field(max_length=20)  # "user", "assistant", "system", "tool"
    content: str = Field(sa_column=Column(Text))  # Unlimited length

    # Timestamp
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)

    # Relationship
    conversation: Conversation = Relationship(back_populates="messages")
```

**Indexes:**
- `conversation_id` + `created_at` - For fetching messages chronologically (performance)

**Constraints:**
- `conversation_id` must reference valid conversation (foreign key)
- `role` must be one of: "user", "assistant", "system", "tool"
- `content` cannot be NULL
- Cascade delete: Deleting conversation deletes all its messages

**Usage Pattern (Stateless - Fetch Message History):**
```python
async def get_conversation_messages(
    db: AsyncSession,
    conversation_id: int,
    limit: int = 20
) -> list[Message]:
    """Fetch last N messages for conversation (stateless)."""
    result = await db.execute(
        select(Message)
        .where(Message.conversation_id == conversation_id)
        .order_by(Message.created_at.desc())  # Most recent first
        .limit(limit)
    )
    messages = result.scalars().all()
    return list(reversed(messages))  # Return oldest first for AI context
```

**Usage Pattern (Store Message):**
```python
async def store_message(
    db: AsyncSession,
    conversation_id: int,
    role: str,
    content: str
) -> Message:
    """Store a message in the database (stateless)."""
    message = Message(
        conversation_id=conversation_id,
        role=role,
        content=content
    )
    db.add(message)
    await db.commit()
    await db.refresh(message)

    # Update conversation's updated_at timestamp
    conversation = await db.get(Conversation, conversation_id)
    conversation.updated_at = datetime.utcnow()
    await db.commit()

    return message
```

---

### Phase III: Pydantic Schemas

**File:** `backend/schemas.py`

```python
class ChatMessageRequest(BaseModel):
    """Schema for incoming chat message."""

    conversation_id: Optional[int] = None
    message: str = Field(..., min_length=1, max_length=5000)

    @validator('message')
    def message_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('Message cannot be empty')
        return v.strip()


class ChatMessageResponse(BaseModel):
    """Schema for chat message response."""

    conversation_id: int
    response: str
    tool_calls: Optional[list[dict]] = None  # For debugging

    class Config:
        from_attributes = True


class ConversationResponse(BaseModel):
    """Schema for conversation response."""

    id: int
    user_id: str
    title: Optional[str]
    created_at: datetime
    updated_at: datetime
    is_active: bool

    class Config:
        from_attributes = True


class MessageResponse(BaseModel):
    """Schema for message response."""

    id: int
    conversation_id: int
    role: str
    content: str
    created_at: datetime

    class Config:
        from_attributes = True
```

---

## 4. API ENDPOINTS

### Endpoint 1: List Tasks

**Method:** `GET`
**Path:** `/api/{user_id}/tasks`
**Query Params:** `status` (optional): "all" | "pending" | "completed"
**Response:** `200 OK`, Array of Task objects
**Errors:** `401 Unauthorized`, `403 Forbidden`

**Implementation:**

```python
@router.get("", response_model=List[TaskResponse])
async def list_tasks(
    user_id: str,
    status: str = "all",
    current_user: str = Depends(verify_jwt),
    db: AsyncSession = Depends(get_db)
):
    """List all tasks for the authenticated user."""

    # Authorization check
    if current_user != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # Build query
    query = select(Task).where(Task.user_id == user_id)

    # Apply status filter
    if status == "pending":
        query = query.where(Task.completed == False)
    elif status == "completed":
        query = query.where(Task.completed == True)

    # Order by newest first
    query = query.order_by(Task.created_at.desc())

    # Execute query
    result = await db.execute(query)
    tasks = result.scalars().all()

    return tasks
```

---

### Endpoint 2: Create Task

**Method:** `POST`
**Path:** `/api/{user_id}/tasks`
**Request Body:** `{"title": string, "description"?: string}`
**Response:** `201 Created`, Task object
**Errors:** `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`

**Implementation:**

```python
@router.post("", response_model=TaskResponse, status_code=201)
async def create_task(
    user_id: str,
    task_data: TaskCreate,
    current_user: str = Depends(verify_jwt),
    db: AsyncSession = Depends(get_db)
):
    """Create a new task for the authenticated user."""

    # Authorization check
    if current_user != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # Create task
    task = Task(
        user_id=user_id,
        title=task_data.title,
        description=task_data.description,
        completed=False
    )

    db.add(task)
    await db.commit()
    await db.refresh(task)

    return task
```

---

### Endpoint 3: Get Task

**Method:** `GET`
**Path:** `/api/{user_id}/tasks/{id}`
**Response:** `200 OK`, Task object
**Errors:** `401 Unauthorized`, `403 Forbidden`, `404 Not Found`

**Implementation:**

```python
@router.get("/{task_id}", response_model=TaskResponse)
async def get_task(
    user_id: str,
    task_id: int,
    current_user: str = Depends(verify_jwt),
    db: AsyncSession = Depends(get_db)
):
    """Get a specific task by ID."""

    # Authorization check
    if current_user != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # Query task
    query = select(Task).where(
        Task.id == task_id,
        Task.user_id == user_id
    )
    result = await db.execute(query)
    task = result.scalar_one_or_none()

    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    return task
```

---

### Endpoint 4: Update Task

**Method:** `PUT`
**Path:** `/api/{user_id}/tasks/{id}`
**Request Body:** `{"title"?: string, "description"?: string, "completed"?: boolean}`
**Response:** `200 OK`, Task object
**Errors:** `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`

**Implementation:**

```python
@router.put("/{task_id}", response_model=TaskResponse)
async def update_task(
    user_id: str,
    task_id: int,
    task_data: TaskUpdate,
    current_user: str = Depends(verify_jwt),
    db: AsyncSession = Depends(get_db)
):
    """Update an existing task."""

    # Authorization check
    if current_user != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # Find task
    query = select(Task).where(
        Task.id == task_id,
        Task.user_id == user_id
    )
    result = await db.execute(query)
    task = result.scalar_one_or_none()

    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    # Update fields
    if task_data.title is not None:
        task.title = task_data.title
    if task_data.description is not None:
        task.description = task_data.description
    if task_data.completed is not None:
        task.completed = task_data.completed

    # Update timestamp
    task.updated_at = datetime.utcnow()

    await db.commit()
    await db.refresh(task)

    return task
```

---

### Endpoint 5: Delete Task

**Method:** `DELETE`
**Path:** `/api/{user_id}/tasks/{id}`
**Response:** `200 OK`, `{"message": "Task deleted"}`
**Errors:** `401 Unauthorized`, `403 Forbidden`, `404 Not Found`

**Implementation:**

```python
@router.delete("/{task_id}")
async def delete_task(
    user_id: str,
    task_id: int,
    current_user: str = Depends(verify_jwt),
    db: AsyncSession = Depends(get_db)
):
    """Delete a task."""

    # Authorization check
    if current_user != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # Find task
    query = select(Task).where(
        Task.id == task_id,
        Task.user_id == user_id
    )
    result = await db.execute(query)
    task = result.scalar_one_or_none()

    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    # Delete task
    await db.delete(task)
    await db.commit()

    return {"message": "Task deleted"}
```

---

### Endpoint 6: Toggle Complete

**Method:** `PATCH`
**Path:** `/api/{user_id}/tasks/{id}/complete`
**Response:** `200 OK`, Task object
**Errors:** `401 Unauthorized`, `403 Forbidden`, `404 Not Found`

**Implementation:**

```python
@router.patch("/{task_id}/complete", response_model=TaskResponse)
async def toggle_complete(
    user_id: str,
    task_id: int,
    current_user: str = Depends(verify_jwt),
    db: AsyncSession = Depends(get_db)
):
    """Toggle task completion status."""

    # Authorization check
    if current_user != user_id:
        raise HTTPException(status_code=403, detail="Forbidden")

    # Find task
    query = select(Task).where(
        Task.id == task_id,
        Task.user_id == user_id
    )
    result = await db.execute(query)
    task = result.scalar_one_or_none()

    if not task:
        raise HTTPException(status_code=404, detail="Task not found")

    # Toggle completion
    task.completed = not task.completed
    task.updated_at = datetime.utcnow()

    await db.commit()
    await db.refresh(task)

    return task
```

---

### Phase III: Chat Message Endpoint

**POST** `/api/chat/message`

**Description:** Send a message to the AI chatbot and receive a response. Handles conversation state persistently in database (stateless architecture).

**Request Body:**
```json
{
  "conversation_id": 1,  // Optional: omit for new conversation
  "message": "Add a task to buy groceries"
}
```

**Response (200 OK):**
```json
{
  "conversation_id": 1,
  "response": "âœ… Created task: Buy groceries. Anything else?",
  "tool_calls": [  // Optional: for debugging
    {
      "tool": "add_task",
      "args": {"user_id": 42, "title": "Buy groceries"},
      "result": {"success": true, "data": {...}}
    }
  ]
}
```

**Implementation:**
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from openai import AsyncOpenAI
from typing import List, Dict, Any

router = APIRouter()


@router.post("/api/chat/message", response_model=ChatMessageResponse)
async def send_chat_message(
    request: ChatMessageRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)  # JWT verification
):
    """
    Process chat message with stateless architecture.

    Stateless Cycle:
    1. Verify JWT and extract user_id
    2. Get or create conversation (from DB)
    3. Fetch conversation history (from DB)
    4. Store user message (to DB)
    5. Build message array for AI
    6. Run OpenAI Agent with MCP tools
    7. Store assistant response (to DB)
    8. Return response to client

    All state in PostgreSQL - server maintains NO memory.
    """

    # STEP 1: User authentication handled by get_current_user dependency
    user_id = current_user.id

    # STEP 2: Get or create conversation (stateless - fetch from DB)
    conversation = await get_or_create_conversation(
        db, user_id, request.conversation_id
    )

    # STEP 3: Fetch conversation history (stateless - last 20 messages)
    messages_history = await get_conversation_messages(
        db, conversation.id, limit=20
    )

    # STEP 4: Store user message in database
    await store_message(
        db=db,
        conversation_id=conversation.id,
        role="user",
        content=request.message
    )

    # STEP 5: Build message array for OpenAI Agent
    message_array = build_message_array(
        history=messages_history,
        new_message=request.message
    )

    # STEP 6: Run OpenAI Agent with MCP tools (stateless)
    openai_client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
    agent = OpenAIAgent(
        client=openai_client,
        system_prompt=TODO_ASSISTANT_SYSTEM_PROMPT,
        tools=get_mcp_tools()  # Returns list of 5 MCP tools
    )

    ai_response, tool_calls = await agent.run(
        messages=message_array,
        user_id=user_id,  # CRITICAL: Always pass user_id for security
        max_iterations=5  # Limit tool call loops
    )

    # STEP 7: Store assistant response in database
    await store_message(
        db=db,
        conversation_id=conversation.id,
        role="assistant",
        content=ai_response
    )

    # STEP 8: Return response to client
    return ChatMessageResponse(
        conversation_id=conversation.id,
        response=ai_response,
        tool_calls=tool_calls if settings.DEBUG else None  # Debug only
    )


def build_message_array(
    history: List[Message],
    new_message: str
) -> List[Dict[str, str]]:
    """Build message array for OpenAI API."""
    messages = [
        {"role": "system", "content": TODO_ASSISTANT_SYSTEM_PROMPT}
    ]

    # Add conversation history
    for msg in history:
        messages.append({
            "role": msg.role,
            "content": msg.content
        })

    # Add new user message
    messages.append({
        "role": "user",
        "content": new_message
    })

    return messages
```

**OpenAI Agent Implementation:**
```python
from openai import AsyncOpenAI
from typing import List, Dict, Any, Tuple


class OpenAIAgent:
    """OpenAI agent with MCP tool calling support."""

    def __init__(
        self,
        client: AsyncOpenAI,
        system_prompt: str,
        tools: List[Dict[str, Any]]
    ):
        self.client = client
        self.system_prompt = system_prompt
        self.tools = tools
        self.model = "gpt-4o"  # or "gpt-4o-mini" for cost savings

    async def run(
        self,
        messages: List[Dict[str, str]],
        user_id: int,
        max_iterations: int = 5
    ) -> Tuple[str, List[Dict[str, Any]]]:
        """
        Run agent with multi-turn tool calling.

        Returns: (final_response, tool_calls_log)
        """
        tool_calls_log = []

        for iteration in range(max_iterations):
            # Call OpenAI API
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                tools=self.tools,
                tool_choice="auto"
            )

            message = response.choices[0].message

            # Check if AI wants to call tools
            if message.tool_calls:
                # Process each tool call
                for tool_call in message.tool_calls:
                    tool_name = tool_call.function.name
                    tool_args = json.loads(tool_call.function.arguments)

                    # CRITICAL: Inject user_id for security
                    tool_args["user_id"] = user_id

                    # Execute tool
                    tool_result = await execute_mcp_tool(
                        tool_name=tool_name,
                        tool_args=tool_args
                    )

                    # Log tool call
                    tool_calls_log.append({
                        "tool": tool_name,
                        "args": tool_args,
                        "result": tool_result
                    })

                    # Add tool result to messages
                    messages.append({
                        "role": "tool",
                        "tool_call_id": tool_call.id,
                        "content": json.dumps(tool_result)
                    })

                # Continue loop with tool results
                continue
            else:
                # No more tool calls - return final response
                return message.content, tool_calls_log

        # Max iterations reached
        return (
            "I had trouble processing that request. Can you simplify?",
            tool_calls_log
        )
```

**MCP Tools Implementation:**
```python
from typing import Dict, Any


async def execute_mcp_tool(
    tool_name: str,
    tool_args: Dict[str, Any]
) -> Dict[str, Any]:
    """Execute an MCP tool by name."""
    tools = {
        "add_task": mcp_add_task,
        "list_tasks": mcp_list_tasks,
        "update_task": mcp_update_task,
        "complete_task": mcp_complete_task,
        "delete_task": mcp_delete_task
    }

    tool_function = tools.get(tool_name)
    if not tool_function:
        return {"success": false, "error": f"Tool '{tool_name}' not found"}

    try:
        result = await tool_function(**tool_args)
        return result
    except Exception as e:
        return {"success": false, "error": str(e)}


async def mcp_add_task(
    user_id: int,
    title: str,
    description: str = None,
    priority: str = "medium",
    tags: List[str] = None,
    due_date: str = None
) -> Dict[str, Any]:
    """MCP Tool: Create a new task."""
    async with get_db_session() as db:
        task = Task(
            user_id=user_id,  # ALWAYS filter by user_id
            title=title,
            description=description,
            # ... additional fields
        )
        db.add(task)
        await db.commit()
        await db.refresh(task)

        return {
            "success": True,
            "data": {
                "id": task.id,
                "title": task.title,
                "description": task.description,
                "completed": task.completed
            }
        }


async def mcp_list_tasks(
    user_id: int,
    status: str = None,
    priority: str = None,
    tags: List[str] = None,
    limit: int = 20
) -> Dict[str, Any]:
    """MCP Tool: List tasks with filters."""
    async with get_db_session() as db:
        query = select(Task).where(
            Task.user_id == user_id  # CRITICAL: user isolation
        )

        if status == "pending":
            query = query.where(Task.completed == False)
        elif status == "completed":
            query = query.where(Task.completed == True)

        # Additional filters...

        result = await db.execute(query.limit(limit))
        tasks = result.scalars().all()

        return {
            "success": True,
            "data": {
                "tasks": [
                    {
                        "id": t.id,
                        "title": t.title,
                        "description": t.description,
                        "completed": t.completed
                    }
                    for t in tasks
                ],
                "count": len(tasks)
            }
        }


# Similar implementations for update_task, complete_task, delete_task
# All MUST filter by user_id for security
```

**System Prompt:**
```python
TODO_ASSISTANT_SYSTEM_PROMPT = """You are a personal TODO assistant helping users manage their tasks.

Available Tools:
- add_task(user_id, title, description?, priority?, tags?, due_date?): Create a new task
- list_tasks(user_id, status?, priority?, tags?, limit?): List tasks with optional filters
- update_task(user_id, task_id, title?, description?, status?, priority?): Update a task
- complete_task(user_id, task_id): Mark a task as completed
- delete_task(user_id, task_id): Delete a task (ASK FOR CONFIRMATION FIRST)

Personality:
- Friendly and helpful
- Concise and action-oriented
- Professional but not robotic
- Celebrate task completions with ğŸ‰
- Confirm actions clearly

Behavioral Rules:
1. Always confirm what you did after calling a tool
2. Ask clarifying questions if request is ambiguous
3. NEVER delete tasks without explicit user confirmation
4. Use emojis sparingly: âœ… âŒ ğŸ¯ ğŸ“… ğŸ‰
5. Offer next steps after completing an action

Example Interactions:
User: "Add task to buy groceries"
You: Call add_task(user_id, "Buy groceries")
You: "âœ… Created task: Buy groceries. Anything else?"

User: "What's on my list?"
You: Call list_tasks(user_id)
You: "You have 3 tasks:
1. â¬œ Buy groceries (medium)
2. â¬œ Finish report (high) - Due Friday
3. âœ… Call dentist (completed)

Would you like to mark any as complete?"

Error Handling:
- If a tool fails, explain what went wrong in user-friendly language
- If you can't find a task, offer to show all tasks
- If request is too complex, ask user to break it down
"""
```

---

## 5. AUTHENTICATION FLOW

### Better Auth + JWT Flow

**1. User Signup/Login:**
```
User â†’ LoginForm â†’ POST /api/auth/login
                        â†“
                Better Auth validates credentials
                        â†“
                Password hash comparison (bcrypt)
                        â†“
                JWT token generated
                        Payload: {
                          sub: user_id,
                          email: user@example.com,
                          name: User Name,
                          iat: timestamp,
                          exp: timestamp + 7 days
                        }
                        Signature: HMAC-SHA256(BETTER_AUTH_SECRET)
                        â†“
                Token stored in httpOnly cookie
                        Cookie attributes: {
                          httpOnly: true,
                          sameSite: 'strict',
                          secure: true (production),
                          maxAge: 7 days
                        }
                        â†“
                User redirected to /tasks
```

**2. API Request with JWT:**
```
Browser â†’ GET /api/{user_id}/tasks
          Cookie: token=<jwt>
                â†“
          FastAPI Backend
                â†“
          JWT Middleware: verify_jwt()
                â†“
          Extract Authorization header
          OR extract from cookie (if configured)
                â†“
          Decode JWT with BETTER_AUTH_SECRET
                â†“
          Verify signature (HMAC-SHA256)
                â†“
          Check expiry (exp claim)
                â†“
          Extract user_id from 'sub' claim
                â†“
          Return user_id to endpoint
                â†“
          Endpoint: Verify user_id matches URL
                â†“
          Query database filtered by user_id
                â†“
          Return response
```

**3. Authorization Check:**
```python
# In every endpoint
current_user = Depends(verify_jwt)  # user_id from token
user_id = path_parameter             # user_id from URL

if current_user != user_id:
    raise HTTPException(status_code=403, detail="Forbidden")

# Only proceed if match
```

### JWT Token Structure

```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "sub": "550e8400-e29b-41d4-a716-446655440000",
    "email": "user@example.com",
    "name": "User Name",
    "iat": 1735689600,
    "exp": 1736294400
  },
  "signature": "HMAC-SHA256(header + payload, BETTER_AUTH_SECRET)"
}
```

**Claims Explanation:**
- `sub` (subject): User ID (UUID string)
- `email`: User's email address
- `name`: User's display name
- `iat` (issued at): Token creation timestamp
- `exp` (expiry): Token expiration timestamp (7 days)

---

## 6. FRONTEND IMPLEMENTATION

### Better Auth Setup

**Installation:**
```bash
cd frontend
npm install better-auth
```

**Configuration:**

**File:** `lib/auth.ts`
```typescript
import { createAuthClient } from 'better-auth'

export const authClient = createAuthClient({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  plugins: {
    jwt: {
      secret: process.env.BETTER_AUTH_SECRET!,
      expiresIn: '7d',
      cookieOptions: {
        httpOnly: true,
        sameSite: 'strict',
        secure: process.env.NODE_ENV === 'production'
      }
    }
  }
})

export async function getUser() {
  const session = await authClient.getSession()
  return session?.user
}

export async function logout() {
  await authClient.signOut()
}
```

**API Routes:**

**File:** `app/api/auth/[...route]/route.ts`
```typescript
import { authClient } from '@/lib/auth'

export const { GET, POST } = authClient.handler()
```

---

### API Client Pattern

**File:** `lib/api.ts`

```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'

async function fetchWithAuth(url: string, options: RequestInit = {}) {
  const response = await fetch(`${API_BASE}${url}`, {
    ...options,
    credentials: 'include', // Send cookies
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
  })

  if (response.status === 401) {
    // Unauthorized - redirect to login
    window.location.href = '/login'
    throw new Error('Unauthorized')
  }

  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.detail || 'API error')
  }

  return response
}

export const api = {
  async getTasks(userId: string, status?: string): Promise<Task[]> {
    const query = status ? `?status=${status}` : ''
    const response = await fetchWithAuth(`/api/${userId}/tasks${query}`)
    return response.json()
  },

  async getTask(userId: string, taskId: number): Promise<Task> {
    const response = await fetchWithAuth(`/api/${userId}/tasks/${taskId}`)
    return response.json()
  },

  async createTask(userId: string, data: TaskCreate): Promise<Task> {
    const response = await fetchWithAuth(`/api/${userId}/tasks`, {
      method: 'POST',
      body: JSON.stringify(data),
    })
    return response.json()
  },

  async updateTask(userId: string, taskId: number, data: TaskUpdate): Promise<Task> {
    const response = await fetchWithAuth(`/api/${userId}/tasks/${taskId}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    })
    return response.json()
  },

  async deleteTask(userId: string, taskId: number): Promise<void> {
    await fetchWithAuth(`/api/${userId}/tasks/${taskId}`, {
      method: 'DELETE',
    })
  },

  async toggleComplete(userId: string, taskId: number): Promise<Task> {
    const response = await fetchWithAuth(`/api/${userId}/tasks/${taskId}/complete`, {
      method: 'PATCH',
    })
    return response.json()
  },
}
```

---

### Component Patterns

**Server Component (Default):**

```typescript
// app/page.tsx
import { getUser } from '@/lib/auth'
import { api } from '@/lib/api'
import { redirect } from 'next/navigation'
import TaskList from '@/components/TaskList'

export default async function HomePage() {
  const user = await getUser()

  if (!user) {
    redirect('/login')
  }

  const tasks = await api.getTasks(user.id)

  return (
    <div>
      <h1>My Tasks</h1>
      <TaskList initialTasks={tasks} userId={user.id} />
    </div>
  )
}
```

**Client Component (Interactive):**

```typescript
// components/TaskItem.tsx
'use client'

import { useState } from 'react'
import { api } from '@/lib/api'
import type { Task } from '@/lib/types'

interface Props {
  task: Task
  userId: string
  onUpdate: (task: Task) => void
  onDelete: (taskId: number) => void
}

export default function TaskItem({ task, userId, onUpdate, onDelete }: Props) {
  const [isLoading, setIsLoading] = useState(false)

  async function handleToggle() {
    setIsLoading(true)
    try {
      const updated = await api.toggleComplete(userId, task.id)
      onUpdate(updated)
    } catch (error) {
      console.error('Failed to toggle task:', error)
    } finally {
      setIsLoading(false)
    }
  }

  async function handleDelete() {
    if (!confirm('Are you sure you want to delete this task?')) return

    setIsLoading(true)
    try {
      await api.deleteTask(userId, task.id)
      onDelete(task.id)
    } catch (error) {
      console.error('Failed to delete task:', error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="flex items-center gap-4 p-4 border rounded">
      <input
        type="checkbox"
        checked={task.completed}
        onChange={handleToggle}
        disabled={isLoading}
        className="w-5 h-5"
      />
      <div className="flex-1">
        <h3 className={task.completed ? 'line-through' : ''}>
          {task.title}
        </h3>
        {task.description && (
          <p className="text-sm text-gray-600">{task.description}</p>
        )}
      </div>
      <button
        onClick={handleDelete}
        disabled={isLoading}
        className="text-red-600 hover:text-red-800"
      >
        Delete
      </button>
    </div>
  )
}
```

---

## 7. BACKEND IMPLEMENTATION

### JWT Verification Middleware

**File:** `middleware/auth.py`

```python
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from config import settings

security = HTTPBearer()

async def verify_jwt(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> str:
    """
    Verify JWT token and extract user_id.

    Args:
        credentials: HTTP Bearer token from Authorization header

    Returns:
        user_id: UUID string from token 'sub' claim

    Raises:
        HTTPException: 401 if token invalid or expired
    """
    token = credentials.credentials

    try:
        # Decode and verify token
        payload = jwt.decode(
            token,
            settings.BETTER_AUTH_SECRET,
            algorithms=["HS256"]
        )

        # Extract user_id from 'sub' claim
        user_id = payload.get("sub")
        if not user_id:
            raise HTTPException(
                status_code=401,
                detail="Invalid token: missing user ID"
            )

        return user_id

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=401,
            detail="Token has expired"
        )
    except jwt.InvalidTokenError:
        raise HTTPException(
            status_code=401,
            detail="Invalid token"
        )
```

---

### Database Connection

**File:** `db.py`

```python
from sqlmodel import create_engine, Session
from sqlmodel.ext.asyncio.session import AsyncSession
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.orm import sessionmaker
from config import settings

# Create async engine
engine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DEBUG,
    pool_pre_ping=True,  # Test connections before use
    pool_size=10,        # Connection pool size
    max_overflow=20,     # Max connections beyond pool_size
    pool_timeout=30      # Timeout for getting connection
)

# Create async session maker
async_session = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db() -> AsyncSession:
    """
    Dependency that provides database session.

    Yields:
        AsyncSession: Database session

    Ensures session is closed and committed/rolled back.
    """
    async with async_session() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
```

---

### FastAPI App Setup

**File:** `main.py`

```python
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from config import settings
from routes import tasks


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan context manager for app startup/shutdown."""
    # Startup: Create tables if needed
    # (In production, use Alembic migrations instead)
    print("Starting up...")
    yield
    # Shutdown: Close connections
    print("Shutting down...")


# Create FastAPI app
app = FastAPI(
    title="Todo API",
    version="2.0.0",
    lifespan=lifespan
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS.split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Register routers
app.include_router(
    tasks.router,
    prefix="/api/{user_id}/tasks",
    tags=["tasks"]
)

# Health check endpoint
@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

---

## 8. DATABASE CONNECTION

### Neon Setup

**1. Create Neon Project:**
- Visit https://neon.tech
- Sign up/log in
- Click "Create Project"
- Name: "todo-app-phase-ii"
- Region: Select closest to your users
- PostgreSQL version: 16 (latest)

**2. Get Connection String:**
- Click "Connection Details"
- Copy connection string
- Format: `postgresql://user:pass@host/db?sslmode=require`
- Convert to asyncpg format: `postgresql+asyncpg://user:pass@host/db?sslmode=require`

**3. Set Environment Variable:**

**Backend `.env`:**
```bash
DATABASE_URL=postgresql+asyncpg://user:password@ep-cool-name-123456.us-east-1.aws.neon.tech/neondb?sslmode=require
BETTER_AUTH_SECRET=your-32-character-secret-key-here
CORS_ORIGINS=http://localhost:3000,https://yourdomain.com
DEBUG=True
```

**4. Test Connection:**
```python
# test_connection.py
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine

async def test():
    engine = create_async_engine("postgresql+asyncpg://...")
    async with engine.connect() as conn:
        result = await conn.execute("SELECT version()")
        print(result.scalar())

asyncio.run(test())
```

---

### Connection Pooling

**Configuration:**

```python
engine = create_async_engine(
    DATABASE_URL,
    echo=DEBUG,                 # Log SQL queries (dev only)
    pool_pre_ping=True,         # Test connections before use
    pool_size=10,               # Base pool size
    max_overflow=20,            # Additional connections allowed
    pool_timeout=30,            # Timeout for getting connection (seconds)
    pool_recycle=3600,          # Recycle connections after 1 hour
)
```

**Benefits:**
- Reuses connections (faster than creating new ones)
- Handles connection failures gracefully
- Scales to handle concurrent requests
- Neon supports up to 100 connections per database

---

## 9. DEPLOYMENT ARCHITECTURE

### Frontend Deployment (Vercel)

**1. Connect GitHub Repository:**
- Go to https://vercel.com
- Click "New Project"
- Import Git Repository
- Select `todo-app` repository

**2. Configure Build:**
- Framework Preset: Next.js
- Root Directory: `frontend`
- Build Command: `npm run build`
- Output Directory: `.next`
- Install Command: `npm install`

**3. Environment Variables:**
```
NEXT_PUBLIC_API_URL=https://api.yourdomain.com
BETTER_AUTH_SECRET=your-32-character-secret-key-here
NODE_ENV=production
```

**4. Deploy:**
- Click "Deploy"
- Vercel auto-deploys on every push to `main`
- Preview deployments for pull requests

**5. Custom Domain (Optional):**
- Add domain in Vercel dashboard
- Configure DNS records
- SSL certificate auto-provisioned

---

### Backend Deployment (Railway)

**1. Create New Project:**
- Go to https://railway.app
- Click "New Project"
- Select "Deploy from GitHub repo"
- Choose `todo-app` repository

**2. Configure Service:**
- Root Directory: `backend`
- Build Command: `pip install -r requirements.txt`
- Start Command: `uvicorn main:app --host 0.0.0.0 --port $PORT`
- Language: Python 3.13

**3. Environment Variables:**
```
# Phase II (Required)
DATABASE_URL=postgresql+asyncpg://...
BETTER_AUTH_SECRET=your-32-character-secret-key-here
CORS_ORIGINS=https://yourdomain.vercel.app
DEBUG=False
PORT=8000

# Phase III (NEW - Required for AI Chatbot)
OPENAI_API_KEY=sk-...your-openai-api-key...
```

**Phase III Note:** OpenAI API key is required for AI chatbot functionality. Get it from https://platform.openai.com/api-keys

**4. Deploy:**
- Railway auto-deploys on push to `main`
- Generates public URL: `https://todo-api-production.up.railway.app`

**Alternative: Render**
- Similar to Railway
- Free tier available
- Good performance for small apps

---

### Database Deployment (Neon)

**Already Deployed:**
- Neon is serverless PostgreSQL
- No deployment needed
- Connection string provided on creation
- Automatic backups
- Auto-scaling connections

**Production Settings:**
- Enable connection pooling
- Set up read replicas (optional)
- Configure backup retention
- Monitor query performance

---

## 10. DEVELOPMENT WORKFLOW

### Local Development Setup

**Prerequisites:**
- Node.js 18+ installed
- Python 3.13+ installed
- UV package manager installed
- Git installed

**Setup Steps:**

```bash
# 1. Clone repository
git clone https://github.com/yourusername/todo-app.git
cd todo-app/phase-2-web-app

# 2. Setup frontend
cd frontend
npm install
cp .env.example .env.local
# Edit .env.local with your values
npm run dev  # http://localhost:3000

# 3. Setup backend (in new terminal)
cd backend
uv venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate
uv pip install -r requirements.txt
cp .env.example .env
# Edit .env with your values
uvicorn main:app --reload  # http://localhost:8000

# 4. Database (Neon cloud - no local setup)
# Just use connection string from Neon dashboard
```

**Environment Files:**

**Frontend `.env.local`:**
```bash
NEXT_PUBLIC_API_URL=http://localhost:8000
BETTER_AUTH_SECRET=your-32-character-secret-key-here
```

**Backend `.env`:**
```bash
DATABASE_URL=postgresql+asyncpg://user:pass@host/db
BETTER_AUTH_SECRET=your-32-character-secret-key-here
CORS_ORIGINS=http://localhost:3000
DEBUG=True
```

---

### Testing Strategy

**Backend Tests (pytest):**

```bash
cd backend
uv run pytest

# With coverage
uv run pytest --cov=. --cov-report=html

# Specific test file
uv run pytest tests/test_tasks.py

# Verbose output
uv run pytest -v
```

**Test Structure:**
```
backend/tests/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ conftest.py              # Fixtures
â”œâ”€â”€ test_models.py           # SQLModel tests
â”œâ”€â”€ test_auth.py             # JWT verification tests
â”œâ”€â”€ test_tasks.py            # Task endpoint tests
â””â”€â”€ test_integration.py      # End-to-end tests
```

**Frontend Tests (Jest):**

```bash
cd frontend
npm test

# Watch mode
npm run test:watch

# Coverage
npm run test:coverage
```

**Test Structure:**
```
frontend/__tests__/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ TaskItem.test.tsx
â”‚   â”œâ”€â”€ TaskList.test.tsx
â”‚   â””â”€â”€ TaskForm.test.tsx
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ api.test.ts
â””â”€â”€ integration/
    â””â”€â”€ auth-flow.test.tsx
```

---

## 11. SECURITY IMPLEMENTATION

### CORS Configuration

**Backend (FastAPI):**

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",          # Development
        "https://yourdomain.vercel.app"   # Production
    ],
    allow_credentials=True,  # Required for cookies
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"],
    allow_headers=["Content-Type", "Authorization"],
    expose_headers=["*"],
)
```

**Why Credentials?**
- Frontend sends cookies with requests
- `credentials: 'include'` in fetch requires backend to allow

---

### Environment Variables

**Shared Across Frontend and Backend:**

```bash
BETTER_AUTH_SECRET=your-minimum-32-character-secret-key-here-use-openssl-rand-hex-32
```

**Critical Security Rules:**
1. **Same secret** in both frontend and backend
2. **Never commit** to Git (use `.env` files, add to `.gitignore`)
3. **Minimum 32 characters** for cryptographic strength
4. **Use environment variables** in production (Vercel/Railway)

**Generate Secret:**
```bash
# Using OpenSSL
openssl rand -hex 32

# Using Python
python -c "import secrets; print(secrets.token_hex(32))"

# Using Node.js
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

---

### User Isolation Enforcement

**Every Endpoint Must:**

```python
# 1. Extract user_id from JWT token
current_user: str = Depends(verify_jwt)

# 2. Extract user_id from URL path
user_id: str  # Path parameter

# 3. Verify they match
if current_user != user_id:
    raise HTTPException(status_code=403, detail="Forbidden")

# 4. Filter all database queries by user_id
query = select(Task).where(Task.user_id == user_id)
```

**Why This Matters:**
- Prevents users from accessing other users' data
- Even if user knows another user's ID, they can't access their tasks
- Authorization check happens on every request
- Database-level enforcement via WHERE clause

---

### Input Validation

**Backend (Pydantic):**

```python
class TaskCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(None, max_length=1000)

    @validator('title')
    def title_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError('Title cannot be empty')
        return v.strip()
```

**Frontend (Form Validation):**

```typescript
function validateTask(data: { title: string; description?: string }) {
  const errors: string[] = []

  if (!data.title.trim()) {
    errors.push('Title is required')
  }

  if (data.title.length > 200) {
    errors.push('Title must be 200 characters or less')
  }

  if (data.description && data.description.length > 1000) {
    errors.push('Description must be 1000 characters or less')
  }

  return errors
}
```

**Defense in Depth:**
- Validate on frontend (UX)
- Validate on backend (security)
- Never trust client input
- SQL injection prevented by SQLModel ORM

---

## 12. IMPLEMENTATION CHECKLIST

### Phase 1: Backend Setup
- [ ] Initialize FastAPI project structure
- [ ] Configure database connection (Neon)
- [ ] Create SQLModel models (User, Task)
- [ ] Create Pydantic schemas
- [ ] Implement JWT verification middleware
- [ ] Create task CRUD endpoints
- [ ] Configure CORS
- [ ] Add health check endpoint
- [ ] Write backend tests (90%+ coverage)
- [ ] Deploy to Railway/Render

### Phase 2: Frontend Setup
- [ ] Initialize Next.js project (App Router)
- [ ] Configure Better Auth
- [ ] Create API client (`lib/api.ts`)
- [ ] Build component library
- [ ] Implement login/signup pages
- [ ] Implement task list page
- [ ] Add loading and error states
- [ ] Write frontend tests (80%+ coverage)
- [ ] Deploy to Vercel

### Phase 3: Integration
- [ ] Test authentication flow end-to-end
- [ ] Test task CRUD operations
- [ ] Test authorization (user isolation)
- [ ] Test error handling
- [ ] Performance testing
- [ ] Security audit

### Phase 4: Production
- [ ] Set up environment variables
- [ ] Configure custom domains
- [ ] Enable HTTPS
- [ ] Set up monitoring
- [ ] Document deployment process
- [ ] Create runbook for common issues

### Phase 5: AI Chatbot (Phase III)
- [ ] Add OpenAI SDK dependencies to backend
- [ ] Create Conversation and Message models
- [ ] Create database migrations for new tables
- [ ] Implement ConversationService (stateless)
- [ ] Implement 5 MCP tools (add/list/update/complete/delete)
- [ ] Create OpenAI Agent class with tool calling
- [ ] Define TODO_ASSISTANT_SYSTEM_PROMPT
- [ ] Implement POST /api/chat/message endpoint
- [ ] Add OPENAI_API_KEY to environment variables
- [ ] Test stateless architecture (server restart scenario)
- [ ] Write tests for MCP tools (user isolation)
- [ ] Write tests for conversation persistence

### Phase 6: Chat Frontend (Phase III)
- [ ] Install OpenAI ChatKit package
- [ ] Create /chat page in Next.js
- [ ] Implement chat UI components
- [ ] Integrate with backend chat API
- [ ] Handle JWT auth in chat requests (credentials: 'include')
- [ ] Implement conversation state management
- [ ] Add loading and error states for chat
- [ ] Test 401 handling (session expiry)
- [ ] Test multi-turn tool calling conversations
- [ ] Test conversation persistence across page refreshes

### Phase 7: AI Integration Testing (Phase III)
- [ ] Test natural language task creation
- [ ] Test task listing via chat
- [ ] Test task completion via chat
- [ ] Test task updates via chat
- [ ] Test task deletion via chat (with confirmation)
- [ ] Test multi-turn conversations (5+ iterations)
- [ ] Test context tracking ("it", "that task" references)
- [ ] Test conversation persistence across sessions
- [ ] Test user isolation (can't access other users' conversations)
- [ ] Test error handling (OpenAI API failures)
- [ ] Performance testing (< 3 second response time)

---

## APPENDIX: TECHNOLOGY DECISIONS

### Why Next.js?
- **Server-side rendering** for better SEO and performance
- **App Router** for modern React patterns
- **Built-in API routes** for Better Auth integration
- **Vercel deployment** for easy hosting
- **TypeScript support** out of the box

### Why FastAPI?
- **Async/await** for high performance
- **Automatic OpenAPI docs** for API exploration
- **Pydantic integration** for validation
- **Type hints** for better developer experience
- **Easy deployment** to Railway/Render

### Why SQLModel?
- **Combines SQLAlchemy + Pydantic** (best of both)
- **Type-safe** database operations
- **Async support** for modern Python
- **Automatic schema validation**
- **PostgreSQL compatibility**

### Why Neon?
- **Serverless** (no infrastructure management)
- **Auto-scaling** connections
- **Instant cold starts**
- **Branching** for development
- **Generous free tier**

### Why Better Auth?
- **JWT plugin** built-in
- **Password hashing** handled
- **Cookie management** automatic
- **Type-safe** client/server
- **Next.js optimized**

---

**END OF IMPLEMENTATION PLAN**

This document defines HOW to build Phase II-III.

**Phase II**: Traditional web UI for task management
**Phase III**: AI-powered chatbot with OpenAI Agents SDK and MCP tools

Next step: Break down into tasks (sp.tasks).

**Version:** 2.0.0
**Date:** 2026-01-12
**Status:** Ready for Task Breakdown
**Phase III Additions:**
- OpenAI Agent with multi-turn tool calling
- 5 MCP tools (add/list/update/complete/delete)
- Stateless conversation architecture
- Conversation and Message models
- POST /api/chat/message endpoint
- OpenAI ChatKit frontend integration
- Comprehensive Phase III implementation checklist

**Next Step:** Create task list (sp.tasks)
